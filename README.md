# ğŸ¬ FFMPEG Video Frame Extractor

> *Automated infrastructure deployment for extracting and serving video frames via Docker, orchestrated with Terraform and Ansible.*

A fully automated solution that provisions AWS infrastructure and deploys a containerized FFMPEG + NGINX application to extract and display the last frame from a video stream. The entire stack is managed as code with zero-touch deployment.

---

## ğŸ¯ Overview

This project demonstrates Infrastructure as Code (IaC) best practices by combining:
- **Terraform** for AWS infrastructure provisioning
- **Ansible** for automated application deployment  
- **Docker Compose** for container orchestration
- **FFMPEG** for video processing
- **NGINX** for web serving
- **AWS** CLI Authentication, which will save the profile to ~/.aws/credentials

**One-command deployment:** Simply run `terraform apply` and the entire infrastructure, networking, compute, and application stack deploys automatically.

---

## ğŸ—ï¸ Architecture

![Architecture Diagram](arch-diagram.png)
---

## ğŸ“‹ Prerequisites

Ensure the following tools are installed on your local machine:

| Tool | Purpose | Installation |
|------|---------|-------------|
| **Terraform** | Infrastructure provisioning | [Download](https://www.terraform.io/downloads) |
| **Ansible** | Configuration management | `pip install ansible` |
| **AWS CLI** | AWS authentication | [Install Guide](https://aws.amazon.com/cli/) |
| **Python 3** | Required by Ansible | Usually pre-installed |

**AWS Configuration:**
- Configure AWS CLI with valid credentials: `aws configure`
- Set your profile in `terraform.tfvars` 
- Ensure your AWS account has permissions to create VPCs, EC2 instances, and security groups

---

## ğŸ“ Project Structure

```
.
â”œâ”€â”€ terraform-infra/
â”‚   â”‚   â”œâ”€â”€ vpc.tf              # VPC with 2 public subnets
â”‚   â”‚   â”œâ”€â”€ ec2.tf              # EC2 instance with security rules
â”‚   â”‚   â”œâ”€â”€ keys.tf             # Auto-generated SSH key pair
â”‚   â”‚   â”œâ”€â”€ data.tf             # Ubuntu AMI lookup
â”‚   â”‚   â””â”€â”€ ansible.tf          # Ansible automation trigger
â”‚   â”‚   â”œâ”€â”€ variables.tf        # Input variables
â”‚   â”‚   â”œâ”€â”€ terraform.tfvars    # Variable values
â”‚   â”‚   â”œâ”€â”€ locals.tf           # Local computed values
â”‚   â”‚   â”œâ”€â”€ outputs.tf          # Output values (IP, instance ID)
â”‚   â”‚   â””â”€â”€ providers.tf        # Provider versions and config
â”‚   â””â”€â”€ templates/
â”‚       â””â”€â”€ inventory.tpl       # Ansible inventory template
â”œâ”€â”€ ansible/
â”‚   â”œâ”€â”€ inventory.ini           # Auto-generated by Terraform
â”‚   â””â”€â”€ deploy.yml              # Deployment playbook
â””â”€â”€ app/
    â”œâ”€â”€ Dockerfile              # Custom FFMPEG image
    â”œâ”€â”€ docker-compose.yaml     # Container orchestration
    â”œâ”€â”€ ffmpeg-lastframe.sh     # Frame extraction script
    â””â”€â”€ index.html              # Web interface
```

---

## ğŸš€ How It Works

### Infrastructure Layer (Terraform)

**1. VPC & Networking (`vpc.tf`)**
- Creates a VPC with CIDR `10.0.0.0/16`
- Provisions 2 public subnets across availability zones: 
  - `10.0.1.0/24` in `${region}a`
  - `10.0.2.0/24` in `${region}b`
- NAT Gateway disabled (public-only architecture)
- Uses Anton Babenko's official VPC module

**2. EC2 Instance (`ec2.tf`)**
- Launches Ubuntu 22.04 LTS (latest AMI auto-selected via data source)
- Instance type: `t3.micro` (configurable)
- Deployed in first public subnet with auto-assigned public IP
- Security group rules:
  - Port 22 (SSH) - Open to My Local IP, configured through a Terraform data source
  - Port 80 (HTTP) - Open to world (0.0.0.0/0)
- Uses Anton Babenko's EC2 instance module

**3. SSH Key Management (`keys.tf`)**
- Generates 2048-bit RSA key pair via TLS provider
- Saves private key as `.pem` file in terraform directory
- Lifecycle policy prevents key regeneration on updates
- Key permissions automatically set to `400`

**4. Ansible Integration (`ansible.tf`)**
- Automatically generates `ansible/inventory.ini` from template
- Uses absolute path to SSH key for reliability
- Waits 30 seconds for EC2 instance to be SSH-ready
- Triggers Ansible playbook automatically after infrastructure is ready
- Re-runs deployment if inventory changes

### Application Layer (Docker)

**1. FFMPEG Container (`Dockerfile`)**
- Base image: `jrottenberg/ffmpeg:7-ubuntu`
- Installs `bc` (binary calculator) for duration math
- Copies and executes `ffmpeg-lastframe.sh`
- Runs once and exits after extracting frame
- Cleans up apt metadata to reduce image size

**2. Frame Extraction Script (`ffmpeg-lastframe.sh`)**
```bash
# 1. Get total video duration using ffprobe
DURATION=$(ffprobe -v error -show_entries format=duration ...)

# 2. Calculate seek position (duration - 0.1 seconds)
SEEK_TIME=$(echo "$DURATION - 0.1" | bc -l)

# 3. Extract last frame with high quality
ffmpeg -ss "$SEEK_TIME" -i "$INPUT_VIDEO" -vframes 1 -q:v 1 -y "$OUTPUT_IMAGE"
```

**How it works:**
- Uses `ffprobe` to determine video length
- Calculates exact timestamp for last frame (0.1s before end)
- Extracts single frame with maximum quality (`-q:v 1`)
- Saves to shared volume as `last_frame.jpg`

**3. Docker Compose Orchestration (`docker-compose.yaml`)**

Two services connected via shared volume:

**FFMPEG Service:**
- Builds custom image from Dockerfile
- Runs once (`restart: no`)
- Mounts `shared-output` volume to `/output`
- Exits after successful frame extraction

**NGINX Service:**
- Uses official `nginx:latest` image
- Depends on FFMPEG completion (`service_completed_successfully`)
- Mounts same `shared-output` volume to web root
- Overlays custom `index.html` for UI
- Exposes port 80 to host

### Deployment Layer (Ansible)

**Playbook (`deploy.yml`) executes these tasks:**

1. **System Preparation**
   - Updates APT cache
   - Installs dependencies (curl, gnupg, etc.)

2. **Docker Installation**
   - Adds Docker GPG key and repository
   - Installs Docker CE, CLI, and containerd
   - Enables Docker service

3. **Docker Compose Installation**
   - Downloads Docker Compose v2.23.0 binary
   - Installs to `/usr/local/bin/docker-compose`
   - Sets executable permissions

4. **Application Deployment**
   - Creates `/home/ffmpeg-app` directory
   - Copies all app files (Dockerfile, compose file, scripts, HTML)
   - Sets script permissions

5. **Container Management**
   - Stops any existing containers
   - Builds FFMPEG image
   - Starts both services
   - Waits for port 80 to be accessible

---

## ğŸ“– Deployment Guide

### Configuration

Edit `terraform-infra/terraform.tfvars` to customize:

```hcl
aws_region       = "eu-north-1"           # AWS region
key_name         = "ffmpeg-project-key"   # SSH key name
instance_name    = "ffmpeg-project-instance"
instance_type    = "t3.micro"             # EC2 instance size
aws_auth_profile = "default"              # AWS CLI profile
vpc_name         = "ffmpeg-vpc"           # VPC name
```

### Deployment

**Single-command deployment:**

```bash
cd terraform-infra
terraform init
terraform apply
```

Type `yes` when prompted. Terraform will:
1. âœ… Create VPC and subnets
2. âœ… Launch EC2 instance
3. âœ… Generate SSH key pair
4. âœ… Configure security groups
5. âœ… Generate Ansible inventory
6. âœ… Wait for instance readiness
7. âœ… Run Ansible playbook
8. âœ… Deploy Docker containers

**Estimated time:** 3-5 minutes

### Verification

**View outputs:**
```bash
terraform output
```

**Access the application:**
```
http://<instance_public_ip>
```

You should see a web page displaying the last frame from Big Buck Bunny!

---

## ğŸ§¹ Cleanup

To destroy all AWS resources:

```bash
cd terraform-infra
terraform destroy
```

Type `yes` when prompted. This will:
- Terminate EC2 instance
- Delete security groups
- Remove VPC and subnets  
- Clean up SSH keys

**Note:** Local `.pem` file and Ansible inventory remain on disk. Delete manually if desired.

---

## ğŸ”§ Technical Details

### Terraform Features Used

- **Modules:** Anton Babenko's community modules for VPC and EC2
- **Data Sources:** Dynamic AMI lookup, external IP detection
- **Locals:** Computed values (IP CIDR formatting)
- **Provisioners:** `local-exec` for Ansible automation
- **Lifecycle Rules:** Prevent SSH key regeneration
- **Templates:** Dynamic Ansible inventory generation
- **Null Resources:** Orchestration delays and triggers

### Docker Features Used

- **Shared volumes:** Inter-container communication
- **Depends_on conditions:** Service completion tracking
- **Layer caching:** Efficient rebuilds

### Ansible Features Used

- **Variables:** Reusable configuration values
- **Handlers:** Could be added for service restarts
- **Wait_for:** Application readiness checks
- **Copy module:** Efficient file transfer

---

## ğŸ¯ Key Design Decisions

**Why this architecture?**

1. **Single-command deployment** - Entire stack via `terraform apply`
2. **Immutable infrastructure** - Terraform manages all resources
3. **Separation of concerns** - Infrastructure, config, and app layers
4. **Community modules** - Production-tested, maintained code
5. **Auto-generated inventory** - No manual Ansible configuration
6. **Stateless FFMPEG** - Runs once, stores result, exits
7. **Shared volumes** - Clean container communication



---

## ğŸš€ Improvements & Next Steps

**Implemented:**
- âœ… Automated infrastructure provisioning
- âœ… Zero-touch deployment
- âœ… Container orchestration
- âœ… Auto-generated inventory
- âœ… Restrict SSH to specific IP using `local.my_ip`
- âœ… Lifecycle management for keys

**Potential enhancements:**

- [ ] Add S3 backend for Terraform state
- [ ] Implement CI/CD with GitHub Actions
- [ ] Add validations for variables

---

**Built using Terraform, Ansible, Docker, FFMPEG, and NGINX**

*Demonstrates: Infrastructure as Code, Configuration Management, Containerization, Automation*# ğŸ¬ FFMPEG Video Frame Extractor

